import os
import struct
import threading
from tkinter import filedialog, messagebox
from collections import defaultdict

plugin_translations = {
    "pt_BR": {
        "plugin_name": "PAC Devil May Cry 3 Special Edition (N. SWITCH)",
        "plugin_description": "Extrai e reconstrói arquivos PAC (Devil May Cry 3 Special Edition) Nintendo Switch",
        "select_pac_file": "Selecione um arquivo PAC",
        "select_list_file": "Selecione o arquivo .txt (lista) gerado pelo extrator",
        "invalid_file_magic": "Arquivo inválido: Magic incorreto (esperado 'PAC\\x00').",
        "file_not_found": "Arquivo não encontrado: {file}",
        "folder_not_found": "Pasta não encontrada: {folder}",
        "empty_list": "A lista está vazia.",
        "missing_files": "Arquivos ausentes:\n{files}",
        "replace_file_question": "O arquivo '{file}' já existe. Deseja substituir?",
        "extraction_completed": "Extração finalizada!\nArquivos salvos em:\n{path}",
        "rebuild_completed": "PAC reconstruído com sucesso:\n{file}",
        "error_writing_pac": "Falha ao escrever o PAC:\n{error}",
        "error": "Erro",
        "completed": "Concluído"
    },
    "en_US": {
        "plugin_name": "PAC Devil May Cry 3 Special Edition (N. SWITCH)",
        "plugin_description": "Extracts and rebuilds PAC files (Devil May Cry 3 Special Edition) Nintendo Switch",
        "select_pac_file": "Select a PAC file",
        "select_list_file": "Select the .txt list file generated by the extractor",
        "invalid_file_magic": "Invalid file: Incorrect magic (expected 'PAC\\x00').",
        "file_not_found": "File not found: {file}",
        "folder_not_found": "Folder not found: {folder}",
        "empty_list": "The list is empty.",
        "missing_files": "Missing files:\n{files}",
        "replace_file_question": "The file '{file}' already exists. Do you want to replace it?",
        "extraction_completed": "Extraction completed!\nFiles saved in:\n{path}",
        "rebuild_completed": "PAC successfully rebuilt:\n{file}",
        "error_writing_pac": "Failed to write PAC:\n{error}",
        "error": "Error",
        "completed": "Completed"
    },
    "es_ES": {
        "plugin_name": "PAC Devil May Cry 3 Special Edition (N. SWITCH)",
        "plugin_description": "Extrae y reconstruye archivos PAC (Devil May Cry 3 Special Edition) Nintendo Switch",
        "select_pac_file": "Seleccione un archivo PAC",
        "select_list_file": "Seleccione el archivo .txt (lista) generado por el extractor",
        "invalid_file_magic": "Archivo inválido: Magic incorrecto (se esperaba 'PAC\\x00').",
        "file_not_found": "Archivo no encontrado: {file}",
        "folder_not_found": "Carpeta no encontrada: {folder}",
        "empty_list": "La lista está vacía.",
        "missing_files": "Archivos ausentes:\n{files}",
        "replace_file_question": "El archivo '{file}' ya existe. ¿Desea reemplazarlo?",
        "extraction_completed": "¡Extracción finalizada!\nArchivos guardados en:\n{path}",
        "rebuild_completed": "PAC reconstruido con éxito:\n{file}",
        "error_writing_pac": "Fallo al escribir el PAC:\n{error}",
        "error": "Error",
        "completed": "Completado"
    }
}

logger = print
current_language = "pt_BR"

def translate(key, **kwargs):
    lang_dict = plugin_translations.get(current_language, plugin_translations["pt_BR"])
    translation = lang_dict.get(key, key)
    if kwargs:
        try:
            return translation.format(**kwargs)
        except:
            return translation
    return translation

def extrair_pac(file_path):
    try:
        with open(file_path, "rb") as f:
            magic = f.read(4)
            if magic != b"PAC\x00":
                messagebox.showerror(translate("error"), translate("invalid_file_magic"))
                return

            file_count = struct.unpack("<I", f.read(4))[0]

            pointers = []
            for _ in range(file_count):
                ptr = struct.unpack("<I", f.read(4))[0]
                pointers.append(ptr)

            out_dir = os.path.join(os.path.dirname(file_path), os.path.splitext(os.path.basename(file_path))[0])
            os.makedirs(out_dir, exist_ok=True)

            f.seek(0, os.SEEK_END)
            total_size = f.tell()

            extracted_files_list = []

            for i in range(file_count):
                start = pointers[i]
                end = pointers[i + 1] if i < file_count -1 else total_size
                size = end - start
                f.seek(start)
                data = f.read(size)

                ext = ".bin"
                if len(data) >= 3 and all(32 <= b < 127 for b in data[:3]):
                    try:
                        ext = "." + data[:3].decode("ascii").strip()
                    except:
                        pass

                file_name = f"{i+1:04}{ext}"
                extracted_files_list.append(file_name)

                with open(os.path.join(out_dir, file_name), "wb") as out_file:
                    out_file.write(data)

            list_path = out_dir + ".txt"
            with open(list_path, "w", encoding="utf-8") as list_file:
                for name in extracted_files_list:
                    list_file.write(name + "\n")

            messagebox.showinfo(translate("completed"), translate("extraction_completed", path=out_dir))
    except FileNotFoundError:
        messagebox.showerror(translate("error"), translate("file_not_found", file=file_path))
    except Exception as e:
        messagebox.showerror(translate("error"), str(e))
        logger(str(e))

def reconstruir_pac(list_path):
    base = os.path.splitext(list_path)[0]
    folder = base
    if not os.path.isdir(folder):
        messagebox.showerror(translate("error"), translate("folder_not_found", folder=folder))
        return

    try:
        with open(list_path, "r", encoding="utf-8") as f:
            lines = [ln.strip() for ln in f.readlines() if ln.strip()]
    except Exception as e:
        messagebox.showerror(translate("error"), str(e))
        logger(str(e))
        return

    if not lines:
        messagebox.showerror(translate("error"), translate("empty_list"))
        return

    missing = [name for name in lines if not os.path.isfile(os.path.join(folder, name))]
    if missing:
        messagebox.showerror(translate("error"), translate("missing_files", files="\n".join(missing)))
        return

    file_count = len(lines)

    file_datas = []
    for name in lines:
        path = os.path.join(folder, name)
        with open(path, "rb") as rf:
            file_datas.append(rf.read())

    header_size = 4  # "PAC\x00"
    count_size = 4
    pointers_size = 4 * file_count
    base_data_offset = header_size + count_size + pointers_size

    pointers = []
    current = base_data_offset
    for data in file_datas:
        pointers.append(current)
        current += len(data)

    out_pac = base + "_mod.pac"
    if os.path.exists(out_pac):
        if not messagebox.askyesno(translate("completed"), translate("replace_file_question", file=out_pac)):
            return

    try:
        with open(out_pac, "wb") as out:
            out.write(b"PAC\x00")
            out.write(struct.pack("<I", file_count))
            for p in pointers:
                out.write(struct.pack("<I", p))
            for data in file_datas:
                out.write(data)
    except Exception as e:
        messagebox.showerror(translate("error"), translate("error_writing_pac", error=str(e)))
        return

    messagebox.showinfo(translate("completed"), translate("rebuild_completed", file=out_pac))

def selecionar_arquivo_pac():
    caminho = filedialog.askopenfilename(
        title=translate("select_pac_file"),
        filetypes=[("PAC files", "*.pac"), (translate("all_files"), "*.*")]
    )
    if caminho:
        threading.Thread(target=extrair_pac, args=(caminho,), daemon=True).start()

def selecionar_arquivo_lista():
    caminho = filedialog.askopenfilename(
        title=translate("select_list_file"),
        filetypes=[("Text files", "*.txt"), (translate("all_files"), "*.*")]
    )
    if caminho:
        threading.Thread(target=reconstruir_pac, args=(caminho,), daemon=True).start()

def register_plugin(log_func=None, option_getter=None, host_language="pt_BR"):
    global logger, current_language
    logger = log_func or print
    current_language = host_language

    def get_plugin_info():
        return {
            "name": translate("plugin_name"),
            "description": translate("plugin_description"),
            "commands": [
                {"label": translate("select_pac_file"), "action": selecionar_arquivo_pac},
                {"label": translate("select_list_file"), "action": selecionar_arquivo_lista},
            ],
        }
    return get_plugin_info
